//TODO maybe get the third convolution to get closer to gausian filter
__device__ __host__ float3 blender(const float3 &a, const float3 &b, const float &bw){
  float t[3] = {(a.x-b.x)/bw,(a.y-b.y)/bw,(a.z-b.z)/bw};
  float result[3] = {0.0f};
  for(int i = 0; i < 3; ++i){
    if(t[i] > 0.5 && t[i] <= 1.5){
      result[i] = (t[i]-1.5)*(t[i]-1.5)/(2.0f);//*bw*bw*bw);
    }
    else if(t[i] < -0.5 && t[i] >= -1.5){
      result[i] = (t[i]+1.5)*(t[i]+1.5)/(2.0f);//*bw*bw*bw);
    }
    else if(t[i] <= 0.5 && t[i] >= -0.5){
      result[i] = (1.5-(t[i]*t[i]))/(2.0f);//*bw*bw*bw);
    }
    else return {0.0f,0.0f,0.0f};
  }
  return {result[0],result[1],result[2]};
}
__device__ __host__ float3 blenderPrime(const float3 &a, const float3 &b, const float &bw){
  float t[3] = {(a.x-b.x)/bw,(a.y-b.y)/bw,(a.z-b.z)/bw};
  float result[3] = {0.0f};
  for(int i = 0; i < 3; ++i){
    if(t[i] > 0.5 && t[i] <= 1.5){
      result[i] = (2.0f*t[i] + 3.0f)/(2.0f);//*bw*bw*bw);
    }
    else if(t[i] < -0.5 && t[i] >= -1.5){
      result[i] = (2.0f*t[i] - 3.0f)/(2.0f);//*bw*bw*bw);
    }
    else if(t[i] <= 0.5 && t[i] >= -0.5){
      result[i] = (-1.0f*t[i]);//(bw*bw*bw);
    }
    else return {0.0f,0.0f,0.0f};
  }
  return {result[0],result[1],result[2]};
}
__device__ __host__ float3 blenderPrimePrime(const float3 &a, const float3 &b, const float &bw){
  float t[3] = {(a.x-b.x)/bw,(a.y-b.y)/bw,(a.z-b.z)/bw};
  float result[3] = {0.0f};
  for(int i = 0; i < 3; ++i){
    if((t[i] > 0.5 && t[i] <= 1.5)||(t[i] < -0.5 && t[i] >= -1.5)){
      result[i] = 1.0f;//(bw*bw*bw);
    }
    else if(t[i] <= 0.5 && t[i] >= -0.5){
      result[i] = -1.0f;//(bw*bw*bw);
    }
    else return {0.0f,0.0f,0.0f};
  }
  return {result[0],result[1],result[2]};
}

__device__ __host__ int3 splitCrunchBits3(const unsigned int &size, const int &key){
  int3 xyz = {0,0,0};
  for(int i = size - 1;i >= 0;){
    xyz.x = (xyz.x << 1) + ((key >> i) & 1);
    --i;
    xyz.y = (xyz.y << 1) + ((key >> i) & 1);
    --i;
    xyz.z = (xyz.z << 1) + ((key >> i) & 1);
    --i;
  }
  return xyz;
}

__global__ void computeVectorFeild(Node* nodeArray, int numFinestNodes, float3* vectorField, float3* normals, float3* points){
  int blockID = blockIdx.y * gridDim.x + blockIdx.x;
  if(blockID < numFinestNodes){
    __shared__ float3 vec;
    vec = {0.0f, 0.0f, 0.0f};
    __syncthreads();
    int neighborIndex = nodeArray[blockID].neighbors[threadIdx.x];
    if(neighborIndex != -1){
      int currentPoint = nodeArray[neighborIndex].pointIndex;
      int stopIndex = nodeArray[neighborIndex].numPoints + currentPoint;
      float3 blend = {0.0f,0.0f,0.0f};
      float width = nodeArray[blockID].width;
      float3 center = nodeArray[blockID].center;
      for(int i = currentPoint; i < stopIndex; ++i){
        //n = 2 Fo(q) make bounds {0.0f, 1.0f}
          //blend = 1.0f - blend;
        //n = 2 Fo(q) make bounds {-1.0f, 0.0f}
          //blend = blend + 1.0f;
        //n currently = 3
        blend = blender(points[i],center,width)*normals[i];
        if(blend.x == 0.0f && blend.y == 0.0f && blend.z == 0.0f) continue;
        atomicAdd(&vec.x, blend.x);
        atomicAdd(&vec.y, blend.y);
        atomicAdd(&vec.z, blend.z);
      }
    }
    __syncthreads();
    if(threadIdx.x != 0) return;
    else vectorField[blockID] = vec;
  }
}
__global__ void computeLdCSR(int depthOfOctree, Node* nodeArray, int numNodes, int depthIndex, float* laplacianValues, int* laplacianIndices, int* numNonZero){
  //TODO fix!
  // int blockID = blockIdx.y * gridDim.x + blockIdx.x;
  // if(blockID < numNodes){
  //   int neighborIndex = nodeArray[blockID + depthIndex].neighbors[threadIdx.x];
  //   if(neighborIndex != -1){
  //     __shared__ int numNonZeroRow;
  //     numNonZeroRow = 0;
  //     __syncthreads();
  //     int3 xyz1;
  //     int3 xyz2;
  //     xyz1 = splitCrunchBits3(depthOfOctree*3, nodeArray[blockID + depthIndex].key);
  //     xyz2 = splitCrunchBits3(depthOfOctree*3, nodeArray[neighborIndex].key);
  //     int mult = pow(2,depthOfOctree + 1) - 1;
  //     float laplacianValue = (fPrimePrimeLUT[xyz1.x*mult + xyz2.x]*fLUT[xyz1.y*mult + xyz2.y]*fLUT[xyz1.z*mult + xyz2.z])+
  //     (fLUT[xyz1.x*mult + xyz2.x]*fPrimePrimeLUT[xyz1.y*mult + xyz2.y]*fLUT[xyz1.z*mult + xyz2.z])+
  //     (fLUT[xyz1.x*mult + xyz2.x]*fLUT[xyz1.y*mult + xyz2.y]*fPrimePrimeLUT[xyz1.z*mult + xyz2.z]);
  //     if(laplacianValue != 0.0f){
  //       laplacianValues[blockID*27 + threadIdx.x] = laplacianValue;
  //       laplacianIndices[blockID*27 + threadIdx.x] = neighborIndex - depthIndex;
  //       atomicAdd(&numNonZeroRow, 1);
  //     }
  //     else{
  //       laplacianIndices[blockID*27 + threadIdx.x] = -1;
  //     }
  //     __syncthreads();
  //     atomicAdd(&numNonZero[blockID + 1], 1);
  //   }
  //   else{
  //     laplacianIndices[blockID*27 + threadIdx.x] = -1;
  //   }
  // }
}
__global__ void pointSumImplicitTraversal(int numPoints, float3* points, Node* nodeArray, int root, float* nodeImplicit, float* sumImplicit){
  int globalID = blockIdx.x *blockDim.x + threadIdx.x;
  __shared__ float blockSumImplicit;
  blockSumImplicit = 0.0f;
  __syncthreads();
  if(globalID < numPoints){
    int nodeIndex = root;
    bool noChildren = false;
    int childIndex = -1;
    int currentNodePointIndex = -1;
    float regPointImplicit = 0.0f;
    float currentImplicit = 0.0f;
    while(!noChildren){
      currentImplicit = nodeImplicit[nodeIndex];

      //LOOOKKKKKK
      regPointImplicit += currentImplicit;
      //printf("%d,%f\n",nodeIndex,nodeImplicit[nodeIndex]);

      for(int i = 0; i < 8; ++i){
        childIndex = nodeArray[nodeIndex].children[i];
        if(childIndex == -1) continue;
        currentNodePointIndex = nodeArray[childIndex].pointIndex;
        if(globalID >= currentNodePointIndex && globalID < currentNodePointIndex + nodeArray[childIndex].numPoints){
          nodeIndex = childIndex;
        }
      }
      if(childIndex == -1){
        //printf("%d = %f\n",globalID,regPointImplicit);
        atomicAdd(&blockSumImplicit, regPointImplicit);
        break;
      }
    }
    __syncthreads();
    if(threadIdx.x == 0){
      atomicAdd(sumImplicit, blockSumImplicit);
    }
  }
}
__global__ void vertexSumImplicitTraversal(int numVertices, Vertex* vertexArray, float* nodeImplicit, float* vertexImplicit, float* sumImplicit, int numPoints){
  int blockID = blockIdx.y * gridDim.x + blockIdx.x;
  if(blockID < numVertices){
    __shared__ float blockImplicit;
    blockImplicit = 0.0f;
    __syncthreads();
    int associatedNode = vertexArray[blockID].nodes[threadIdx.x];
    if(associatedNode != -1){
      atomicAdd(&blockImplicit, nodeImplicit[associatedNode]);
    }
    __syncthreads();
    if(threadIdx.x == 0){
      float regAVGImp = (*sumImplicit)/numPoints;
      vertexImplicit[blockID] = blockImplicit - regAVGImp;
    }
  }
}


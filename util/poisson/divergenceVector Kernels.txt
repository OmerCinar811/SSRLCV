__global__ void computeDivergenceFine(int depthOfOctree, Node* nodeArray, int numNodes, int depthIndex, float3* vectorField, float* divCoeff, float* fPrimeLUT){
  int blockID = blockIdx.y * gridDim.x + blockIdx.x;
  if(blockID < numNodes){
    __shared__ float coeff;
    int neighborIndex = nodeArray[blockID + depthIndex].neighbors[threadIdx.x];
    if(neighborIndex != -1){
      int numFinestChildren = nodeArray[neighborIndex].numFinestChildren;
      int finestChildIndex = nodeArray[neighborIndex].finestChildIndex;
      int3 xyz1;
      int3 xyz2;
      xyz1 = splitCrunchBits3(depthOfOctree*3, nodeArray[blockID + depthIndex].key);
      int mult = pow(2,depthOfOctree + 1) - 1;
      for(int i = finestChildIndex; i < finestChildIndex + numFinestChildren; ++i){
        xyz2 = splitCrunchBits3(depthOfOctree*3, nodeArray[i].key);
        atomicAdd(&coeff, dotProduct(vectorField[i], {fPrimeLUT[xyz1.x*mult + xyz2.x],fPrimeLUT[xyz1.y*mult + xyz2.y],fPrimeLUT[xyz1.z*mult + xyz2.z]}));
      }
      __syncthreads();
      //may want only one thread doing this should not matter though
      divCoeff[blockID + depthIndex] = coeff;
    }
  }
}
__global__ void findRelatedChildren(Node* nodeArray, int numNodes, int depthIndex, int2* relativityIndicators){
  int blockID = blockIdx.y * gridDim.x + blockIdx.x;
  if(blockID < numNodes){
    __shared__ int numRelativeChildren;
    __shared__ int firstRelativeChild;
    numRelativeChildren = 0;
    firstRelativeChild = 2147483647;//max int
    int neighborIndex = nodeArray[blockID + depthIndex].neighbors[threadIdx.x];
    if(neighborIndex != -1){
      //may not be helping anything by doing this but it prevents 2 accesses to global memory
      int registerChildChecker = nodeArray[neighborIndex].numFinestChildren;
      int registerChildIndex = nodeArray[neighborIndex].finestChildIndex;
      if(registerChildIndex != -1 && registerChildChecker != 0){
        atomicAdd(&numRelativeChildren, nodeArray[neighborIndex].numFinestChildren);
        atomicMin(&firstRelativeChild, nodeArray[neighborIndex].finestChildIndex);
      }
    }
    __syncthreads();
    //may want only one thread doing this should not matter though
    relativityIndicators[blockID].x = firstRelativeChild;
    relativityIndicators[blockID].y = numRelativeChildren;
  }
}
__global__ void computeDivergenceCoarse(int depthOfOctree, Node* nodeArray, int2* relativityIndicators, int currentNode, int depthIndex, float3* vectorField, float* divCoeff, float* fPrimeLUT){
  //TODO optimize with warp aggregated atomics
  int globalID = blockIdx.x *blockDim.x + threadIdx.x;
  if(globalID < relativityIndicators[currentNode].y){
    globalID += relativityIndicators[currentNode].x;
    int3 xyz1;
    int3 xyz2;
    xyz1 = splitCrunchBits3(depthOfOctree*3, nodeArray[currentNode + depthIndex].key);
    xyz2 = splitCrunchBits3(depthOfOctree*3, nodeArray[globalID].key);
    int mult = pow(2,depthOfOctree + 1) - 1;
    //TODO try and find a way to optimize this so that it is not using atomics and global memory
    float fx,fy,fz;
    fx = fPrimeLUT[xyz1.x*mult + xyz2.x];
    fy = fPrimeLUT[xyz1.y*mult + xyz2.y];
    fz = fPrimeLUT[xyz1.z*mult + xyz2.z];
    float divergenceContributer = dotProduct(vectorField[globalID], {fx,fy,fz});
    atomicAdd(&divCoeff[currentNode + depthIndex], divergenceContributer);
  }
}


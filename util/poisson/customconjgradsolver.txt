__global__ void multiplyLdAnd1D(int numNodesAtDepth, float* laplacianValues, int* laplacianIndices, float* matrix1D, float* result){
  int blockID = blockIdx.y * gridDim.x + blockIdx.x;
  if(blockID < numNodesAtDepth){
    __shared__ float resultElement;
    // may need to do the following
    // resultElement = 0.0f;
    // __syncthreads();
    int laplacianIndex = laplacianIndices[blockID*27 + threadIdx.x];
    if(laplacianIndex != -1){
      //printf("%f,%f\n", laplacianValues[blockID*27 + threadIdx.x],matrix1D[laplacianIndex]);
      atomicAdd(&resultElement, laplacianValues[blockID*27 + threadIdx.x]*matrix1D[laplacianIndex]);
    }
    __syncthreads();
    if(threadIdx.x == 0 && resultElement != 0.0f){
      atomicAdd(&result[blockID], resultElement);
    }
  }
}
__global__ void computeAlpha(int numNodesAtDepth, float* r, float* pTL, float* p, float* numerator, float* denominator){
  *numerator = 0.0f;
  *denominator = 0.0f;
  __syncthreads();
  int globalID = blockIdx.x * blockDim.x + threadIdx.x;
  if(globalID < numNodesAtDepth){
    __shared__ float numeratorPartial;
    __shared__ float denominatorPartial;
    numeratorPartial = 0.0f;
    denominatorPartial = 0.0f;
    __syncthreads();
    atomicAdd(&numeratorPartial, r[globalID]*r[globalID]);
    atomicAdd(&denominatorPartial, pTL[globalID]*p[globalID]);
    __syncthreads();
    if(threadIdx.x == 0 && numeratorPartial != 0.0f && denominatorPartial != 0.0f){
      atomicAdd(numerator, numeratorPartial);
      atomicAdd(denominator, denominatorPartial);
    }
  }
}
__global__ void updateX(int numNodesAtDepth, int depthIndex, float* x, float alpha, float* p){
  int globalID = blockIdx.x *blockDim.x + threadIdx.x;
  if(globalID < numNodesAtDepth){
    x[globalID + depthIndex] = alpha*p[globalID] + x[globalID + depthIndex];
  }
}
__global__ void computeRNew(int numNodesAtDepth, float* r, float alpha, float* temp){
  int globalID = blockIdx.x *blockDim.x + threadIdx.x;
  if(globalID < numNodesAtDepth){
    float registerPlaceHolder = 0.0f;
    registerPlaceHolder = -1.0f*alpha*temp[globalID] + r[globalID];
    temp[globalID] = registerPlaceHolder;

  }
}
__global__ void computeBeta(int numNodesAtDepth, float* r, float* rNew, float* numerator, float* denominator){
  *numerator = 0.0f;
  *denominator = 0.0f;
  __syncthreads();
  int globalID = blockIdx.x *blockDim.x + threadIdx.x;
  if(globalID < numNodesAtDepth){
    __shared__ float numeratorPartial;
    __shared__ float denominatorPartial;
    numeratorPartial = 0.0f;
    denominatorPartial = 0.0f;
    __syncthreads();
    atomicAdd(&numeratorPartial, rNew[globalID]*rNew[globalID]);
    atomicAdd(&denominatorPartial, r[globalID]*r[globalID]);
    __syncthreads();
    if(threadIdx.x == 0){
      atomicAdd(numerator, numeratorPartial);
      atomicAdd(denominator, denominatorPartial);
    }
  }
}
__global__ void updateP(int numNodesAtDepth, float* rNew, float beta, float* p){
  int globalID = blockIdx.x *blockDim.x + threadIdx.x;
  if(globalID < numNodesAtDepth){
    p[globalID] = beta*p[globalID] + rNew[globalID];
  }
}

void Surface::computeImplicitFunction(){
  this->computeLUTs();
  this->computeDivergenceVector();

  clock_t timer;
  timer = clock();
  clock_t cudatimer;
  cudatimer = clock();

  unsigned int size = (pow(2, this->octree->depth + 1) - 1);
  float* nodeImplicit = new float[this->octree->totalNodes];
  for(int i = 0; i < this->octree->totalNodes; ++i){
    nodeImplicit[i] = 0.0f;
  }

  int numNodesAtDepth = 0;
  float* temp;
  int* tempInt;
  float* laplacianValuesDevice;
  int* laplacianIndicesDevice;
  float* rDevice;
  float* pDevice;
  float* temp1DDevice;
  dim3 grid;
  dim3 block;
  dim3 grid1D;
  dim3 block1D;
  float alpha = 0.0f;
  float beta = 0.0f;
  float* numeratorDevice;
  float* denominatorDevice;
  float denominator = 0.0f;
  CudaSafeCall(cudaMalloc((void**)&numeratorDevice, sizeof(float)));
  CudaSafeCall(cudaMalloc((void**)&denominatorDevice, sizeof(float)));
  CudaSafeCall(cudaMalloc((void**)&this->fLUTDevice, size*size*sizeof(float)));
  CudaSafeCall(cudaMalloc((void**)&this->fPrimePrimeLUTDevice, size*size*sizeof(float)));
  CudaSafeCall(cudaMalloc((void**)&this->nodeImplicitDevice, this->octree->totalNodes*sizeof(float)));
  CudaSafeCall(cudaMemcpy(numeratorDevice, &alpha, sizeof(float), cudaMemcpyHostToDevice));
  CudaSafeCall(cudaMemcpy(denominatorDevice, &alpha, sizeof(float), cudaMemcpyHostToDevice));
  CudaSafeCall(cudaMemcpy(this->fLUTDevice, this->fLUT, size*size*sizeof(float), cudaMemcpyHostToDevice));
  CudaSafeCall(cudaMemcpy(this->fPrimePrimeLUTDevice, this->fPrimePrimeLUT, size*size*sizeof(float), cudaMemcpyHostToDevice));
  CudaSafeCall(cudaMemcpy(this->nodeImplicitDevice, nodeImplicit, this->octree->totalNodes*sizeof(float), cudaMemcpyHostToDevice));

  for(int d = this->octree->depth; d >= 0; --d){
    //update divergence coefficients based on solutions at coarser depths
    grid = {1,1,1};
    block = {27,1,1};
    if(d != this->octree->depth){
      numNodesAtDepth = this->octree->depthIndex[d + 1] - this->octree->depthIndex[d];
      if(numNodesAtDepth < 65535) grid.x = (unsigned int) numNodesAtDepth;
      else{
        grid.x = 65535;
        while(grid.x*grid.y < numNodesAtDepth){
          ++grid.y;
        }
        while(grid.x*grid.y > numNodesAtDepth){
          --grid.x;
        }
        if(grid.x*grid.y < numNodesAtDepth){
          ++grid.x;
        }
      }
      for(int dcoarse = this->octree->depth; dcoarse >= d + 1; --dcoarse){
        updateDivergence<<<grid, block>>>(this->octree->depth, this->octree->finalNodeArrayDevice, numNodesAtDepth,
          this->octree->depthIndex[d], this->divergenceVectorDevice,
          this->fLUTDevice, this->fPrimePrimeLUTDevice, this->nodeImplicitDevice);
        CudaCheckError();
        exit(0);
      }
    }
    else{
      numNodesAtDepth = 1;
    }

    temp = new float[numNodesAtDepth*27];
    tempInt = new int[numNodesAtDepth*27];
    for(int i = 0; i < numNodesAtDepth*27; ++i){
      temp[i] = 0.0f;
      tempInt[i] = -1;
    }

    CudaSafeCall(cudaMalloc((void**)&laplacianValuesDevice, numNodesAtDepth*27*sizeof(float)));
    CudaSafeCall(cudaMalloc((void**)&laplacianIndicesDevice, numNodesAtDepth*27*sizeof(int)));
    CudaSafeCall(cudaMemcpy(laplacianValuesDevice, temp, numNodesAtDepth*27*sizeof(float), cudaMemcpyHostToDevice));
    CudaSafeCall(cudaMemcpy(laplacianIndicesDevice, tempInt, numNodesAtDepth*27*sizeof(int), cudaMemcpyHostToDevice));
    computeLd<<<grid, block>>>(this->octree->depth, this->octree->finalNodeArrayDevice, numNodesAtDepth, this->octree->depthIndex[d],
      laplacianValuesDevice, laplacianIndicesDevice, this->fLUTDevice, this->fPrimePrimeLUTDevice);
    CudaCheckError();

    CudaSafeCall(cudaMalloc((void**)&temp1DDevice, numNodesAtDepth*sizeof(float)));
    CudaSafeCall(cudaMalloc((void**)&pDevice, numNodesAtDepth*sizeof(float)));
    CudaSafeCall(cudaMalloc((void**)&rDevice, numNodesAtDepth*sizeof(float)));
    CudaSafeCall(cudaMemcpy(temp1DDevice, temp, numNodesAtDepth*sizeof(float),cudaMemcpyHostToDevice));
    CudaSafeCall(cudaMemcpy(rDevice, this->divergenceVectorDevice + this->octree->depthIndex[d], numNodesAtDepth*sizeof(float),cudaMemcpyDeviceToDevice));
    CudaSafeCall(cudaMemcpy(pDevice, this->divergenceVectorDevice + this->octree->depthIndex[d], numNodesAtDepth*sizeof(float),cudaMemcpyDeviceToDevice));

    delete[] temp;
    delete[] tempInt;

    //gradient solver r = b - Lx
    //r is instantiated as b
    //will converge in n iterations
    grid1D = {1,1,1};
    block1D = {1,1,1};
    //this will allow for at most ~67,000,000 numNodesAtDepth
    if(numNodesAtDepth < 65535) grid.x = (unsigned int) numNodesAtDepth;
    else{
      grid1D.x = 65535;
      while(grid1D.x*block1D.x < numNodesAtDepth){
        ++block1D.x;
      }
      while(grid1D.x*block1D.x > numNodesAtDepth){
        --grid1D.x;
      }
      if(grid1D.x*block1D.x < numNodesAtDepth){
        ++grid1D.x;
      }
    }
    // 1.temp = pT * Ld
    // 2.alpha = dot(r,r)/dot(temp,p)
    // 3.x = x + alpha*p
    // 4.temp = Ld * p
    // 5.temp = r - alpha*temp
    // 6.if(rValues == 0.0f) gradientSolverConverged = true, break
    // 7.p = temp + (dot(temp,temp)/dot(r,r))*p
    // STEPS 1 and 4 MAY RESULT IN THE SAME THING
    beta = 0.0f;
    alpha = 0.0f;
    for(int i = 0; i < numNodesAtDepth; ++i){
      multiplyLdAnd1D<<<grid, block>>>(numNodesAtDepth, laplacianValuesDevice, laplacianIndicesDevice, pDevice, temp1DDevice);
      CudaCheckError();
      cudaDeviceSynchronize();
      computeAlpha<<<grid1D, block1D>>>(numNodesAtDepth, rDevice, temp1DDevice, pDevice, numeratorDevice, denominatorDevice);
      CudaCheckError();
      CudaSafeCall(cudaMemcpy(&alpha, numeratorDevice, sizeof(float), cudaMemcpyDeviceToHost));
      CudaSafeCall(cudaMemcpy(&denominator, denominatorDevice, sizeof(float), cudaMemcpyDeviceToHost));
      alpha /= denominator;
      updateX<<<grid1D, block1D>>>(numNodesAtDepth, this->octree->depthIndex[d], this->nodeImplicitDevice, alpha, pDevice);
      CudaCheckError();
      computeRNew<<<grid1D, block1D>>>(numNodesAtDepth, rDevice, alpha, temp1DDevice);
      CudaCheckError();
      cudaDeviceSynchronize();
      computeBeta<<<grid1D, block1D>>>(numNodesAtDepth, rDevice, temp1DDevice, numeratorDevice, denominatorDevice);
      CudaCheckError();
      CudaSafeCall(cudaMemcpy(&beta, numeratorDevice, sizeof(float), cudaMemcpyDeviceToHost));
      CudaSafeCall(cudaMemcpy(&denominator, denominatorDevice, sizeof(float), cudaMemcpyDeviceToHost));

      beta /= denominator;
      //std::cout<<beta<<std::endl;
      if(denominator == 0.0f || .01 > sqrtf(beta)){
        printf("CONVERGED AT %d\n",i);
        break;
      }
      if(isfinite(beta) == 0){
        exit(0);
      }
      updateP<<<grid1D, block1D>>>(numNodesAtDepth, rDevice, beta, pDevice);
      CudaCheckError();
      CudaSafeCall(cudaMemcpy(rDevice, temp1DDevice, numNodesAtDepth*sizeof(float), cudaMemcpyDeviceToDevice));
    }
    CudaSafeCall(cudaFree(laplacianValuesDevice));
    CudaSafeCall(cudaFree(laplacianIndicesDevice));
    CudaSafeCall(cudaFree(temp1DDevice));
    CudaSafeCall(cudaFree(rDevice));
    CudaSafeCall(cudaFree(pDevice));
    cudatimer = clock() - cudatimer;
    //printf("beta was %f at convergence\n",beta);
    printf("Node Implicit computation for depth %d took %f seconds w/%d nodes.\n", this->octree->depth - d,((float) cudatimer)/CLOCKS_PER_SEC, numNodesAtDepth);
    cudatimer = clock();
  }
  CudaSafeCall(cudaFree(numeratorDevice));
  CudaSafeCall(cudaFree(denominatorDevice));
  CudaSafeCall(cudaFree(this->fLUTDevice));
  CudaSafeCall(cudaFree(this->fPrimePrimeLUTDevice));
  CudaSafeCall(cudaFree(this->divergenceVectorDevice));
  delete[] this->fLUT;
  delete[] this->fPrimePrimeLUT;
  delete[] nodeImplicit;
  timer = clock() - timer;
  printf("Node Implicit compuation took a total of %f seconds.\n\n",((float) timer)/CLOCKS_PER_SEC);
}

